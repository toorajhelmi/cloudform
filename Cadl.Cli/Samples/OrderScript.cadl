//the first param is type of the component and second it the name of the deployed component
//the lower case intake is the name of the component used to refer back to this component
//within this script
//trigger specifies what triggers the function which could be request or timer
//  -The request post body is placed in a variable called order
component(Function, ProcessOrder) processOrder size:F
    trigger(request, order)
{
    //Runs a SQL SELECT statement on db 'Transaction' assigning the result is assigned to stock
    //Note that if result is a scalar (int, string, ...) you should use x = sql(Table) and if result 
    //is a list you should use sql(Table, x)
    stock = sql(Transaction)
    {
        select Available from Inventory
        where ItemId = [int]@order.ItemId
    }
    
    //Notice there is a @ behind a parameters. @ is used to indicate
    //the parameter is passed into the statement from the code at run time. 
    //You need to use @ for any non constant parameter on the right side of 
    //statements
    //
    //Note that we are running two SQL statements to retireive the same
    // row (above & below). This is for illustration. We could have used 
    // sql(Transaction, invenroty) to get all the values into inventory & then
    //use inventory.Quantity or inventory.OnHold to access these values.
    //
    onHold = sql(Transaction)
    {  
        select OnHold from Inventory
        where ItemId = [int]@order.ItemId
    }
    
    if (stock - onHold >= order.Quantity)
    {
        //Runs a SQL INSERT statement on db 'Transaction'
        sql(Transaction)
        {
            insert into Hold (ItemId, Expiration, Quantity)
            select [int]@order.ItemId, DATEADD(minute, 5, GETDATE()), [int]@order.Quantity
        }
        
        var newHold = onHold + order.Quantity;
        
        //Runs a SQL UPDATE statement
        sql(Transaction)
        {
            update Inventory
            set OnHold = [int]@newHold
            where Id = [int]@order.ItemId
        }
        
        //Runs a SQL INSERT statement and assgined the new ID to order.Id
        order.Id = sql(Transaction)
        {
            insert into [Order] (CustomerId, ItemId, Quantity, [Status])
            output inserted.#Id
            values ([uniqueidentifier]@order.CustomerId, [int]@order.ItemId, [int]@order.Quantity, 1)
        }
                 
        enqueue(paymentQueue, order)

        var processing = 
        {
            OrderId: order.Id,
            OrderStatus: 1
        };
        
        return processing
    }
    else
    {
        sql(Transaction)
        {
            update Order
            set Status = 5
            where Id = [uniqueidentifier]@order.Id
        }
        
        var processing = 
        {
            OrderId: order.Id,
            OrderStatus: 5
        };

        return processing
    }
}

component(SQL, Transaction) transactions
{
    Table([Customer])
    [
        Id          uniqueIdentifier    not null  default NewId()    PRIMARY KEY,
        FirstName   varchar(100),
        LastName    varchar(100),
        Email       varchar(100)        not null,
        Password    varchar(100)        not null
    ]
    
    Table([Order])
    [
        Id          uniqueIdentifier     not null  default NewId()    PRIMARY KEY,
        CustomerId  uniqueIdentifier     not null  REFERENCES [Customer] (Id),
        ItemId      int                  not null,
        Quantity    int                  not null,
        Status      int                  not null

    ]
    
    Table([OrderStatus])
    [
        Id          uniqueIdentifier     not null  default NewId()    PRIMARY KEY,
        StatusId    int                  not null,
        Name        varchar(50)          not null
    ]
    {
        (StatusId, Name) 
        Values
            (1, 'Pending Payment'),
            (2, 'Pending Receipt'),
            (3, 'Payment Declined'),
            (4, 'Processed'),
            (5, 'Out Of Stock')
    }
    
    Table(Inventory)
    [
        Id          uniqueIdentifier     not null  default NewId()    PRIMARY KEY,
        ItemId      int                  not null,
        Available   int                  not null,
        OnHold      int                  not null
    ]
    
    Table(Hold)
    [
        Id          uniqueIdentifier     not null  default NewId()    PRIMARY KEY,
        ItemId      int                  not null,
        Expiration  datetime             not null,
        Quantity    int                  not null
    ]
}

component(Queue, payment) paymentQueue 

//Triggered when a new object is added to the payment queue.
component(Function, ProcessPayment) processPayment size:F
    trigger(queue, paymentQueue, order)
{
    //Takes the object placed in the payment queue and assigns it to order
    //order = dequeue(paymentQueue)
    
    //code will place a placeholder function to be field by the developer.
    //-1st arg is the name of the function
    //-The rest are inputs tp the function
    //-Returned value is assiged to a variable called processed
    processed = code(processPayment, order)
    
    if (processed)
    {
        sql(Transaction)
        {
            update Order
            set Status = 2
            where Id = [uniqueidentifier]@order.Id
        }
        sql(Transaction)
        {
            update Inventory
            set Available = Available - [int]@order.Quantity,
            Set OnHold = OnHold - [int]@order.Quantity
            where Id = [int]@order.ItemId
        }
        enqueue(receiptQueue, order)
    }
    else
    {
        sql(Transaction)
        {
            update Order
            set status = 3
            where Id = [uniqueidentifier]@order.Id
        }
    }
}

component(Function, CheckHolds) checkHolds 
    trigger(timer, 60) //Trigger every 60 seconds
{
    sql(Transaction, expiredHolds)
    {
        select * from Hold
        where Expiration < GETDATE()
    }
    
    //use iterate to loop on a list. 
    //if there is no await call inside the loop, iterate will act like
    //an normal forEach. Otherwise it will implement an async forEach.
    //
    //SQL statements are awaited so we need to use iterate. JS forEach will
    //not work
    expiredHolds.iterate((expiredHold) =>
    {
        sql(Transaction)
        {
            update Inventory 
            set OnHold = OnHold - [int]@expiredHold.Quantity
            where ItemId = [int]@expiredHold.ItemId
        }
        sql(Transaction)
        {
            delete Hold
            where Id = [uniqueidentifier]@expiredHold.Id
        }  
    });
}

component(Queue, receipt) receiptQueue

component(Function, GenerateReceipt) generateReceipt size:F
    trigger(queue, receiptQueue ,order)
{
    //order = dequeue(receiptQueue)
    code(generateReceipt, order)
    sql(Transaction)
    {
        update Order
        set Status = 4
        where Id = [uniqueidentifier]@order.Id
    }
}







